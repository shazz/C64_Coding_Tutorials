	processor	6502
	org	$0810

	; set interrupts registers
	sei			; disable  interrupt

	; lda #<irq	; Set IRQ address low byte in a
	; ldx #>irq	; Set IRQ address high byte in x
	; sta $0314	; set Execution address   of interrupt service routine to low byte irq address
	; stx $0315	; set Execution address+1 of interrupt service routine to high byte irq address

	; lda #$7f	; a = $7f = %0111 1111
	; sta $dc0d	; Set Interrupt control to enable all timers interrupts
	; ; sta $dd0d	; Set Interrupt control to enable all timers interrupts

	; lda #$1b	; a = $1b = 0001 1011
	; sta $d01b
	; lda #$01	; a = 1
	; sta $d01a	; set Interrupt control register to enable raster interrupts only

	lda #$7f	; a = $7f = %0111 1111
	sta $dc0d	; Set Interrupt control to enable all timers interrupts
	sta $dd0d	; Set Interrupt control to enable all timers interrupts

	lda #$01	; a = 1
	sta $d01a	; set Interrupt control register to enable raster interrupts only

	; set screen
	lda #$1b	; a = $1b = 0001 1011
	ldx #$08	; x = $8 = 0000 1000
	ldy #$14	; y = $14 = 0001 010 0,  $24 = 0010 010 0

	sta $d011	; Screen control register #1 = a => in text mode
	stx $d016	; Screen control register #2 = x => 40 columns mode
	sty $d018	; Set memory setup register to charmem at 1000-$17FF and screen ram to $0400-$07FF => bad as driver is in $0400?

	lda #<irq	; Set IRQ address low byte in a
	ldx #>irq	; Set IRQ address high byte in x
	ldy #$7e	; y = $7e
	sta $0314	; set Execution address   of interrupt service routine to low byte irq address
	stx $0315	; set Execution address+1 of interrupt service routine to high byte irq address
	sty $d012	; set Raster line to generate interrupt at raster line $7e = 126

	; read interrupt registes clear them
	lda $dc0d	; read interrupt control register 1 in a
	lda $dd0d	; read interrupt control register 2 in a
	asl $d019	; Ack raster interrupt

	; init player
    lda #$36    ; TURN OFF BASIC ROM to access addres behind the BASIC ROM ($A000-$BFFF)
    sta $01

	lda #$00	; a = 0
	tax			; x = 0
	tay			; y = 0

	jsr $A600	; jump to SID player init
	lda #$37 	; TURN BASIC ROM BACK ON
    sta $01

	cli			; enable interrupts
loop:
	jmp loop

irq:
	lda #$01
	sta $d019
	; asl $d019	; Ack any raster interrupt

	; lda #$0		; a = 0
	; sta $d012	; set Raster line to generate interrupt at raster line 0

    lda #$36    ; TURN OFF BASIC ROM
    sta $01
	inc $d020
	jsr $A603	; call SID player
	dec $d020
	lda #$37 	; TURN BASIC ROM ON
    sta $01

	jmp $ea81	; Others can be ended with JMP $EA81, which simply goes to the end of the kernel handler.

; SID details
; | Addresses    : DRIVER = $0400-$04FF, INIT = $A600    |
; |              : LOAD   = $A600-$B717, PLAY = $A603    |

	org $A600-$7c-2
	INCBIN "Cybernoid_II.sid"

; $DC0D : Interrupt control and status register. CIA1
; Read bits:
;     Bit #0: 1 = Timer A underflow occurred.
;     Bit #1: 1 = Timer B underflow occurred.
;     Bit #2: 1 = TOD is equal to alarm time.
;     Bit #3: 1 = A complete byte has been received into or sent from serial shift register.
;     Bit #4: Signal level on FLAG pin, datasette input.
;     Bit #7: An interrupt has been generated.

; Write bits:
;     Bit #0: 1 = Enable interrupts generated by timer A underflow.
;     Bit #1: 1 = Enable interrupts generated by timer B underflow.
;     Bit #2: 1 = Enable TOD alarm interrupt.
;     Bit #3: 1 = Enable interrupts generated by a byte having been received/sent via serial shift register.
;     Bit #4: 1 = Enable interrupts generated by positive edge on FLAG pin.
;     Bit #7: Fill bit; bits #0-#6, that are set to 1, get their values from this bit; bits #0-#6, that are set to 0, are left unchanged.

; $DD0D: Interrupt control and status register. CIA2
; Read bits:
;     Bit #0: 1 = Timer A underflow occurred.
;     Bit #1: 1 = Timer B underflow occurred.
;     Bit #2: 1 = TOD is equal to alarm time.
;     Bit #3: 1 = A complete byte has been received into or sent from serial shift register.
;     Bit #4: Signal level on FLAG pin.
;     Bit #7: A non-maskable interrupt has been generated.

; Write bits:
;     Bit #0: 1 = Enable non-maskable interrupts generated by timer A underflow.
;     Bit #1: 1 = Enable non-maskable interrupts generated by timer B underflow.
;     Bit #2: 1 = Enable TOD alarm non-maskable interrupt.
;     Bit #3: 1 = Enable non-maskable interrupts generated by a byte having been received/sent via serial shift register.
;     Bit #4: 1 = Enable non-maskable interrupts generated by positive edge on FLAG pin.
;     Bit #7: Fill bit; bits #0-#6, that are set to 1, get their values from this bit; bits #0-#6, that are set to 0, are left unchanged.

; $D01A: Interrupt control register. Bits:
;     Bit #0: 1 = Raster interrupt enabled.
;     Bit #1: 1 = Sprite-background collision interrupt enabled.
;     Bit #2: 1 = Sprite-sprite collision interrupt enabled.
;     Bit #3: 1 = Light pen interrupt enabled.

; 0001 	1 	Register 	6510 CPU's on-chip port register
; Bit 0 - LORAM: Configures RAM or ROM at $A000-$BFFF (see bankswitching)
; Bit 1 - HIRAM: Configures RAM or ROM at $E000-$FFFF (see bankswitching)
; Bit 2 - CHAREN: Configures I/O or ROM at $D000-$DFFF (see bankswitching)
; Bit 3 - Cassette Data Output Line (Datasette)
; Bit 4 - Cassette Switch Sense; 1 = Switch Closed
; Bit 5 - Cassette Motor Control; 0 = On, 1 = Off
; Bit 6 - Undefined
; Bit 7 - Undefined
; 36 = 0011 0110 => disable basic
; 35 = 0011 0101 => disable kernal
; 37 = 0011 0111 =>